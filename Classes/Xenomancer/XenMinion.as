string strXenMinionSoundCreate = "debris/beamstart7.wav";

// Precache strings for monsters. (Yawn)

/* -- Removed as they flinch, retreat and hesitate too much due to pack tactics.
// Houndeye.
    // Models/Sprites.
    string strHoundeyeModel = "models/houndeye.mdl";
    string strHoundeyeSpriteShockwave = "sprites/shockwave.spr";
    string strHoundeyeSoundAlert1 = "houndeye/he_alert1.wav";
    string strHoundeyeSoundAlert2 = "houndeye/he_alert2.wav";
    string strHoundeyeSoundAlert3 = "houndeye/he_alert3.wav";
    string strHoundeyeSoundAttack1 = "houndeye/he_attack1.wav";
    string strHoundeyeSoundAttack2 = "houndeye/he_attack2.wav";
    string strHoundeyeSoundAttack3 = "houndeye/he_attack3.wav";
    string strHoundeyeSoundBlast1 = "houndeye/he_blast1.wav";
    string strHoundeyeSoundBlast2 = "houndeye/he_blast2.wav";
    string strHoundeyeSoundBlast3 = "houndeye/he_blast3.wav";
    string strHoundeyeSoundDie1 = "houndeye/he_die1.wav";
    string strHoundeyeSoundDie2 = "houndeye/he_die2.wav";
    string strHoundeyeSoundDie3 = "houndeye/he_die3.wav";
    string strHoundeyeSoundHunt1 = "houndeye/he_hunt1.wav";
    string strHoundeyeSoundHunt2 = "houndeye/he_hunt2.wav";
    string strHoundeyeSoundHunt3 = "houndeye/he_hunt3.wav";
    string strHoundeyeSoundHunt4 = "houndeye/he_hunt4.wav";
    string strHoundeyeSoundIdle1 = "houndeye/he_idle1.wav";
    string strHoundeyeSoundIdle2 = "houndeye/he_idle2.wav";
    string strHoundeyeSoundIdle3 = "houndeye/he_idle3.wav";
    string strHoundeyeSoundIdle4 = "houndeye/he_idle4.wav";
    string strHoundeyeSoundPain1 = "houndeye/he_pain1.wav";
    string strHoundeyeSoundPain2 = "houndeye/he_pain2.wav";
    string strHoundeyeSoundPain3 = "houndeye/he_pain3.wav";
    string strHoundeyeSoundPain4 = "houndeye/he_pain4.wav";
    string strHoundeyeSoundPain5 = "houndeye/he_pain5.wav";
*/

// Pitdrone.
    // Models/Sprites.
    string strPitdroneModel = "models/pit_drone.mdl";
    string strPitdroneModelGibs = "models/pit_drone_gibs.mdl";
    string strPitdroneModelSpike = "models/pit_drone_spike.mdl";

    // Sounds.
    string strPitdroneSpikeTrail = "sprites/spike_trail.spr";
    string strPitdroneSoundAttackSpike1 = "pitdrone/pit_drone_attack_spike1.wav";
    string strPitdroneSoundAlert1 = "pitdrone/pit_drone_alert1.wav";
    string strPitdroneSoundAlert2 = "pitdrone/pit_drone_alert2.wav"; 
    string strPitdroneSoundAlert3 = "pitdrone/pit_drone_alert3.wav"; 
    string strPitdroneSoundIdle1 = "pitdrone/pit_drone_idle1.wav";
    string strPitdroneSoundIdle2 = "pitdrone/pit_drone_idle2.wav";
    string strPitdroneSoundIdle3 = "pitdrone/pit_drone_idle3.wav";
    string strPitdroneSoundDie1 = "pitdrone/pit_drone_die1.wav";
    string strPitdroneSoundDie2 = "pitdrone/pit_drone_die2.wav";
    string strPitdroneSoundDie3 = "pitdrone/pit_drone_die3.wav";
    string strPitdroneSoundBite2 = "bullchicken/bc_bite2.wav";
    string strPitdroneSoundPain1 = "pitdrone/pit_drone_pain1.wav";
    string strPitdroneSoundPain2 = "pitdrone/pit_drone_pain2.wav";
    string strPitdroneSoundPain3 = "pitdrone/pit_drone_pain3.wav";
    string strPitdroneSoundPain4 = "pitdrone/pit_drone_pain4.wav";
    string strPitdroneSoundMelee1 = "pitdrone/pit_drone_melee_attack1.wav";
    string strPitdroneSoundMelee2 = "pitdrone/pit_drone_melee_attack2.wav";
    string strPitdroneSoundEat = "pitdrone/pit_drone_eat.wav";

// Bullsquid
    // Models/Sprites.
    string strBullsquidModel = "models/bullsquid.mdl";
    string strBullsquidSpriteTinyspit = "sprites/tinyspit.spr";
    string strBullsquidSpriteBigspit = "sprites/bigspit.spr";

    // Sounds.
    string strBullsquidAcid1 = "bullchicken/bc_acid1.wav";
    string strBullsquidAcid2 = "bullchicken/bc_acid2.wav";
    string strBullsquidAttack1 = "bullchicken/bc_attack1.wav";
    string strBullsquidAttack2 = "bullchicken/bc_attack2.wav";
    string strBullsquidAttack3 = "bullchicken/bc_attack3.wav";
    string strBullsquidAttackGrowl = "bullchicken/bc_attackgrowl.wav";
    string strBullsquidAttackGrowl2 = "bullchicken/bc_attackgrowl2.wav";
    string strBullsquidAttackGrowl3 = "bullchicken/bc_attackgrowl3.wav";
    string strBullsquidBite1 = "bullchicken/bc_bite1.wav";
    string strBullsquidBite2 = "bullchicken/bc_bite2.wav";
    string strBullsquidBite3 = "bullchicken/bc_bite3.wav";
    string strBullsquidDie1 = "bullchicken/bc_die1.wav";
    string strBullsquidDie2 = "bullchicken/bc_die2.wav";
    string strBullsquidDie3 = "bullchicken/bc_die3.wav";
    string strBullsquidIdle1 = "bullchicken/bc_idle1.wav";
    string strBullsquidIdle2 = "bullchicken/bc_idle2.wav";
    string strBullsquidIdle3 = "bullchicken/bc_idle3.wav";
    string strBullsquidIdle4 = "bullchicken/bc_idle4.wav";
    string strBullsquidIdle5 = "bullchicken/bc_idle5.wav";
    string strBullsquidSoundPain1 = "bullchicken/bc_pain1.wav";
    string strBullsquidSoundPain2 = "bullchicken/bc_pain2.wav";
    string strBullsquidSoundPain3 = "bullchicken/bc_pain3.wav";
    string strBullsquidSoundPain4 = "bullchicken/bc_pain4.wav";
    string strBullsquidSpithit1 = "bullchicken/bc_spithit1.wav";
    string strBullsquidSpithit2 = "bullchicken/bc_spithit2.wav";
    string strBullsquidSpithit3 = "bullchicken/bc_spithit3.wav";

// Shocktrooper.
    // Models/Sprites.
    string strShocktrooperModel = "models/strooper.mdl";
    string strShocktrooperModelGibs = "models/strooper_gibs.mdl";
    string strShocktrooperSpriteMuzzleshock = "sprites/muzzle_shock.spr";

    // Sounds.
    string strShocktrooperBlis = "shocktrooper/blis.wav";
    string strShocktrooperDit = "shocktrooper/dit.wav";
    string strShocktrooperDup = "shocktrooper/dup.wav";
    string strShocktrooperGa = "shocktrooper/ga.wav";
    string strShocktrooperHyu = "shocktrooper/hyu.wav";
    string strShocktrooperKa = "shocktrooper/ka.wav";
    string strShocktrooperKiml = "shocktrooper/kiml.wav";
    string strShocktrooperKss = "shocktrooper/kss.wav";
    string strShocktrooperKu = "shocktrooper/ku.wav";
    string strShocktrooperKur = "shocktrooper/kur.wav";
    string strShocktrooperKyur = "shocktrooper/kyur.wav";
    string strShocktrooperMub = "shocktrooper/mub.wav";
    string strShocktrooperPuh = "shocktrooper/puh.wav";
    string strShocktrooperPur = "shocktrooper/pur.wav";
    string strShocktrooperRas = "shocktrooper/ras.wav";
    string strShocktrooperThirv = "shocktrooper/thirv.wav";
    string strShocktrooperWirt = "shocktrooper/wirt.wav";
    string strShocktrooperFire = "shocktrooper/shock_fire.wav";
    string strShocktrooperAttack = "shocktrooper/shock_trooper_die1.wav";
    string strShocktrooperDie1 = "shocktrooper/shock_trooper_die1.wav";
    string strShocktrooperDie2 = "shocktrooper/shock_trooper_die2.wav";
    string strShocktrooperDie3 = "shocktrooper/shock_trooper_die3.wav";
    string strShocktrooperDie4 = "shocktrooper/shock_trooper_die4.wav";
    string strShocktrooperPain1 = "shocktrooper/shock_trooper_pain1.wav";
    string strShocktrooperPain2 = "shocktrooper/shock_trooper_pain2.wav";
    string strShocktrooperPain3 = "shocktrooper/shock_trooper_pain3.wav";
    string strShocktrooperPain4 = "shocktrooper/shock_trooper_pain4.wav";
    string strShocktrooperPain5 = "shocktrooper/shock_trooper_pain5.wav";

/*
// Alien Grunt (Friendly). DISABLED FOR NOW.
    // Models/Sprites.
    string strAlienGruntModel = "models/agruntf.mdl";
    string strAlienGruntModelGibs = "models/fleshgibs.mdl";
    string strAlienGruntMuzzleFlash = "sprites/muz4.spr";

    // Sounds.
    string strAlienGruntSoundIdle1 = "agrunt/ag_idle1.wav";
    string strAlienGruntSoundIdle2 = "agrunt/ag_idle2.wav";
    string strAlienGruntSoundIdle3 = "agrunt/ag_idle3.wav";
    string strAlienGruntSoundIdle4 = "agrunt/ag_idle4.wav";
    string strAlienGruntSoundDie1 = "agrunt/ag_die1.wav";
    string strAlienGruntSoundDie4 = "agrunt/ag_die4.wav";
    string strAlienGruntSoundDie5 = "agrunt/ag_die5.wav";
    string strAlienGruntSoundPain1 = "agrunt/ag_pain1.wav";
    string strAlienGruntSoundPain2 = "agrunt/ag_pain2.wav";
    string strAlienGruntSoundPain3 = "agrunt/ag_pain3.wav";
    string strAlienGruntSoundPain4 = "agrunt/ag_pain4.wav";
    string strAlienGruntSoundPain5 = "agrunt/ag_pain5.wav";
    string strAlienGruntSoundAttack1 = "agrunt/ag_attack1.wav";
    string strAlienGruntSoundAttack2 = "agrunt/ag_attack2.wav";
    string strAlienGruntSoundAttack3 = "agrunt/ag_attack3.wav";
    string strAlienGruntSoundAlert1 = "agrunt/ag_alert1.wav";
    string strAlienGruntSoundAlert3 = "agrunt/ag_alert3.wav";
    string strAlienGruntSoundAlert4 = "agrunt/ag_alert4.wav";
    string strAlienGruntSoundAlert5 = "agrunt/ag_alert5.wav";
*/

    // Baby Gargantua. Adult one is way too strong :P.
    // Models/Sprites.
    string strBabyGargModel = "models/babygarg.mdl";
    string strBabyGargSpriteEye = "sprites/gargeye1.spr";
    string strBabyGargSpriteBeam = "sprites/xbeam3.spr";

    // Sounds.
    string strBabyGargSoundAlert1 = "babygarg/gar_alert1.wav";
    string strBabyGargSoundAlert2 = "babygarg/gar_alert2.wav";
    string strBabyGargSoundAlert3 = "babygarg/gar_alert3.wav";
    string strBabyGargSoundAttack1 = "babygarg/gar_attack1.wav";
    string strBabyGargSoundAttack2 = "babygarg/gar_attack2.wav";
    string strBabyGargSoundAttack3 = "babygarg/gar_attack3.wav";
    string strBabyGargSoundBreathe1 = "babygarg/gar_breathe1.wav";
    string strBabyGargSoundBreathe2 = "babygarg/gar_breathe2.wav";
    string strBabyGargSoundBreathe3 = "babygarg/gar_breathe3.wav";
    string strBabyGargSoundDie1 = "babygarg/gar_die1.wav";
    string strBabyGargSoundDie2 = "babygarg/gar_die2.wav";
    string strBabyGargSoundFlameoff1 = "babygarg/gar_flameoff1.wav";
    string strBabyGargSoundFlameon1 = "babygarg/gar_flameon1.wav";
    string strBabyGargSoundFlamerun1 = "babygarg/gar_flamerun1.wav";
    string strBabyGargSoundIdle1 = "babygarg/gar_idle1.wav";
    string strBabyGargSoundIdle2 = "babygarg/gar_idle2.wav";
    string strBabyGargSoundIdle3 = "babygarg/gar_idle3.wav";
    string strBabyGargSoundIdle4 = "babygarg/gar_idle4.wav";
    string strBabyGargSoundIdle5 = "babygarg/gar_idle5.wav";
    string strBabyGargSoundPain1 = "babygarg/gar_pain1.wav";
    string strBabyGargSoundPain2 = "babygarg/gar_pain2.wav";
    string strBabyGargSoundPain3 = "babygarg/gar_pain3.wav";
    string strBabyGargSoundStep1 = "babygarg/gar_step1.wav";
    string strBabyGargSoundStep2 = "babygarg/gar_step2.wav";
    string strBabyGargSoundStomp1 = "babygarg/gar_stomp1.wav";

dictionary g_XenologistMinions;

enum XenType
{   
    XEN_PITDRONE = 0,
    XEN_BULLSQUID = 1,
    XEN_SHOCKTROOPER = 2,
    XEN_BABYGARG = 3
}

const array<float> XEN_ANIMATION_SPEEDS = 
{
    1.40,  // Pit Drone.
    2.00,  // Bullsquid.
    1.40,  // Shocktrooper.
    1.30   // Baby Gargantua.
};

const array<string> XEN_NAMES = 
{
    "Pit Drone",
    "Bullsquid",
    "Shocktrooper",
    "Baby Gargantua"
    //"Alien Grunt"
    
};

const array<string> XEN_ENTITIES = 
{
    "monster_pitdrone",
    "monster_bullchicken",
    "monster_shocktrooper",
    "monster_babygarg"
    //"monster_alien_grunt"
    
};

const array<int> XEN_COSTS = // Pool cost per summon of each type.
{
    1, // Pit Drone.
    1, // Bullsquid.
    1, // Shocktrooper.
    2  // Baby Garg.
};

// Level requirements for each Xen creature type.
const array<int> XEN_LEVEL_REQUIREMENTS = 
{   
    1,    // Pitdrone.
    5,    // Bullsquid.
    10,   // Shocktrooper.
    20    // Baby Garg.
};

// Structure to track minion type
class XenMinionInfo
{
    EHandle hMinion;
    int type;
    
    XenMinionInfo() { type = 0; }
    XenMinionInfo(EHandle h, int t) { hMinion = h; type = t; }
}

class XenMinionData
{
    private XenMinionMenu@ m_pMenu;
    private array<XenMinionInfo> m_hMinions;
    private bool m_bActive = false;
    private float m_flBaseHealth = 300.0;
    private float m_flHealthScale = 0.18; // Health % scaling per level.
    private float m_flHealthRegen = 0.001; // // Health recovery % per second of Minions.
    private float m_flLastRegenTime = 0.0f; // Track last regen time.
    private float m_flRegenInterval = 1.0f; // Interval for regen.
    private float m_flDamageScale = 0.12; // Damage % scaling per level.
    private float m_flLifestealPercent = 0.10; // 10% of minion damage is returned as health to the owner (Enhancement).
    private int m_iMinionResourceCost = 1; // Cost to summon specific minion.
    private float m_flReservePool = 0.0f;
    private float m_flLastToggleTime = 0.0f;
    private float m_flLastMessageTime = 0.0f;
    private float m_flToggleCooldown = 1.0f;
    private ClassStats@ m_pStats = null;

    bool IsActive() 
    { 
        // Clean invalid minions first.
        for(int i = m_hMinions.length() - 1; i >= 0; i--)
        {
            // Checking IsValid(), GetEntity(), and also if the entity is alive.
            EHandle hMinion = m_hMinions[i].hMinion;
            if(!hMinion.IsValid())
            {
                m_hMinions.removeAt(i);
                continue;
            }
            
            CBaseEntity@ pEntity = hMinion.GetEntity();
            if(pEntity is null || !pEntity.IsAlive() || pEntity.pev.health <= 0)
            {
                m_hMinions.removeAt(i);
            }
        }
        
        // The minions are active if there are any in the list.
        return m_hMinions.length() > 0;
    }

    void Initialize(ClassStats@ stats) { @m_pStats = stats; }

    ClassStats@ GetStats() { return m_pStats; }

    int GetMinionCount() { return m_hMinions.length(); }

    float GetReservePool() { return m_flReservePool; }
    
    void SetReservePoolZero() { m_flReservePool = 0.0f; }
    
    float GetMinionRegen() { return m_flHealthRegen; }

    float GetLifestealPercent() 
    { 
        // Only return lifesteal percent if Enhancement 1 is unlocked.
        return (m_pStats !is null && m_pStats.HasUnlockedPerk1()) ? m_flLifestealPercent : 0.0f;
    }

    bool HasStats() { return m_pStats !is null; }
    
    bool IsMinionTypeUnlocked(int minionType)
    {
        if(m_pStats is null)
            return minionType == XEN_PITDRONE; // Only allow Pitdrones if no stats.
            
        int playerLevel = m_pStats.GetLevel();
        return playerLevel >= XEN_LEVEL_REQUIREMENTS[minionType];
    }
    
    array<XenMinionInfo>@ GetMinions() { return m_hMinions; }
    
    CBaseEntity@ GetMinionEntity(uint index)
    {
        if(index >= m_hMinions.length())
            return null;
            
        // Validate the entity reference before returning it.
        CBaseEntity@ pMinion = m_hMinions[index].hMinion.GetEntity();
        if(pMinion is null || pMinion.pev.health <= 0)
        {
            // Entity is invalid or dead, remove it from our list.
            m_hMinions.removeAt(index);
            RecalculateReservePool();
            return null;
        }
        
        return pMinion;
    }

    XenMinionData() 
    {
        @m_pMenu = XenMinionMenu(this);
    }

    void SpawnXenMinion(CBasePlayer@ pPlayer)
    {
        if(pPlayer is null || !pPlayer.IsConnected() || !pPlayer.IsAlive())
            return;

        float currentTime = g_Engine.time;
        if(currentTime - m_flLastToggleTime < m_flToggleCooldown)
            return;

        m_pMenu.ShowXenMinionMenu(pPlayer); // Show menu.
    }

    void SpawnSpecificMinion(CBasePlayer@ pPlayer, int minionType)
    {
        if(pPlayer is null || !pPlayer.IsConnected() || !pPlayer.IsAlive())
            return;

        string steamID = g_EngineFuncs.GetPlayerAuthId(pPlayer.edict());
        if(!g_PlayerClassResources.exists(steamID))
            return;

        dictionary@ resources = cast<dictionary@>(g_PlayerClassResources[steamID]);
        int current = int(resources['current']);
        
        // First clean up invalid minions to make sure we have an accurate count.
        for(int i = m_hMinions.length() - 1; i >= 0; i--)
        {
            if(!m_hMinions[i].hMinion.IsValid())
            {
                m_hMinions.removeAt(i);
            }
        }

        // Check resources for spawning new minion.
        if(current < XEN_COSTS[minionType])
        {
            g_PlayerFuncs.ClientPrint(pPlayer, HUD_PRINTCENTER, "Not enough points for " + XEN_NAMES[minionType] + "!\n");
            return;
        }
        
        // Calculate max resources and ensure we're within limits.
        float maxEnergy = float(resources['max']);
        if(m_flReservePool + XEN_COSTS[minionType] > maxEnergy)
        {
            g_PlayerFuncs.ClientPrint(pPlayer, HUD_PRINTCENTER, "Maximum Creature Capacity reached!\n");
            return;
        }

        // Initialize stats if needed.
        if(m_pStats is null)
        {
            if(g_PlayerRPGData.exists(steamID))
            {
                PlayerData@ data = cast<PlayerData@>(g_PlayerRPGData[steamID]);
                if(data !is null && data.GetCurrentClass() == PlayerClass::CLASS_XENOMANCER)
                {
                    @m_pStats = data.GetCurrentClassStats();
                }
            }
        }
        
        // Check if the minion type is unlocked based on player level.
        if(!IsMinionTypeUnlocked(minionType))
        {
            g_PlayerFuncs.ClientPrint(pPlayer, HUD_PRINTCENTER, "" + XEN_NAMES[minionType] + " requires Lv. " + XEN_LEVEL_REQUIREMENTS[minionType] + "!\n");
            return;
        }

        Vector vecSrc = pPlayer.GetGunPosition();
        Vector spawnForward, spawnRight, spawnUp;
        g_EngineFuncs.AngleVectors(pPlayer.pev.v_angle, spawnForward, spawnRight, spawnUp);
        
        vecSrc = vecSrc + (spawnForward * 64);
        vecSrc.z -= 32;

        float scaledHealth = GetScaledHealth();
        float scaledDamage = GetScaledDamage();
        
        dictionary keys;
        keys["origin"] = vecSrc.ToString();
        keys["angles"] = Vector(0, pPlayer.pev.v_angle.y, 0).ToString();
        keys["targetname"] = "_xenminion_" + pPlayer.entindex();
        keys["displayname"] = string(pPlayer.pev.netname) + "'s " + XEN_NAMES[minionType];
        keys["health"] = string(scaledHealth);
        keys["scale"] = "1";
        keys["friendly"] = "1";
        keys["spawnflag"] = "32";
        keys["is_player_ally"] = "1";

        CBaseEntity@ pXenMinion = g_EntityFuncs.CreateEntity(XEN_ENTITIES[minionType], keys, true);
        if(pXenMinion !is null)
        {
            // Apply glow effect before dispatch.
            ApplyMinionGlow(pXenMinion);

            g_EntityFuncs.DispatchSpawn(pXenMinion.edict()); // Dispatch the entity.

            // Stuff to set after dispatch.
            @pXenMinion.pev.owner = @pPlayer.edict(); // Set the owner to the spawning player.

            // Store both the minion handle and its type
            XenMinionInfo info;
            info.hMinion = EHandle(pXenMinion);
            info.type = minionType;
            m_hMinions.insertLast(info);
            
            m_flReservePool += XEN_COSTS[minionType]; // Add to reserve pool when minion is created.
            current -= XEN_COSTS[minionType]; // Subtract from current resources.
            resources['current'] = current;

            g_SoundSystem.EmitSound(pPlayer.edict(), CHAN_STATIC, strXenMinionSoundCreate, 1.0f, ATTN_NORM);
            g_PlayerFuncs.ClientPrint(pPlayer, HUD_PRINTCENTER, XEN_NAMES[minionType] + " summoned!\n");
        }
    }

    void XenUpdate(CBasePlayer@ pPlayer)
    {
        if(pPlayer is null)
            return;

        // Remove invalid Minions and check frags.
        for(int i = m_hMinions.length() - 1; i >= 0; i--)
        {
            CBaseEntity@ pExistingMinion = m_hMinions[i].hMinion.GetEntity();
            
            // If the minion no longer exists in the game world.
            if(pExistingMinion is null)
            {
                // Remove from our list and update reserve pool.
                m_hMinions.removeAt(i);
                continue;
            }
            
            // Cast to CBaseMonster to check monster-specific properties.
            CBaseMonster@ pMonster = cast<CBaseMonster@>(pExistingMinion);

            // Set some values after casting incase they override.
            int minionType = m_hMinions[i].type;
            if(minionType >= 0 && uint(minionType) < XEN_ANIMATION_SPEEDS.length())
            {
                pMonster.pev.framerate = XEN_ANIMATION_SPEEDS[minionType]; // Different speeds per minion type.
            }

            pMonster.m_flFieldOfView = -1.0; // Max their field of view so they become more effective.
            
            // Enhanced death check - check multiple conditions.
            bool isDead = false;
            
            if(pMonster !is null)
            {
                isDead = (pMonster.pev.deadflag != DEAD_NO);
            }
            
            // Also check standard health and IsAlive.
            if(isDead || pExistingMinion.pev.health <= 0 || !pExistingMinion.IsAlive())
            {
                // Use Killed to properly destroy the minion.
                pExistingMinion.Killed(pPlayer.pev, GIB_ALWAYS); // Ensure gibbing to remove possibility of revival.
                
                // Also immediately remove from our list to prevent multiple Killed calls.
                m_hMinions.removeAt(i);
                continue;
            }

            // Check if minion has gained a frag.
            if(pExistingMinion.pev.frags > 0)
            {
                pPlayer.pev.frags += 1;
                pExistingMinion.pev.frags = 0;
            }
            
            // Ensure max_health is properly set during updates.
            if(pExistingMinion.pev.max_health <= 0)
            {
                // Get the creature type from our stored information
                int creatureType = m_hMinions[i].type;
                
                // Use our scaled health formula that accounts for player level.
                pExistingMinion.pev.max_health = GetScaledHealth();
            }
            
            // Ensure glow effect is maintained.
            ApplyMinionGlow(pExistingMinion);
        }

        // Always recalculate the reserve pool to ensure it's accurate.
        RecalculateReservePool();

        // Update stats reference for stat menu.
        if(m_pStats is null)
        {
            string steamID = g_EngineFuncs.GetPlayerAuthId(pPlayer.edict());
            if(g_PlayerRPGData.exists(steamID))
            {
                PlayerData@ data = cast<PlayerData@>(g_PlayerRPGData[steamID]);
                if(data !is null && data.GetCurrentClass() == PlayerClass::CLASS_XENOMANCER)
                {
                    @m_pStats = data.GetCurrentClassStats();
                }
            }
        }
    }

    void DestroyAllMinions(CBasePlayer@ pPlayer)
    {
        if(pPlayer is null || m_hMinions.length() == 0)
            return;

        uint MinionCount = m_hMinions.length();
        if(MinionCount == 0)
        {
            g_PlayerFuncs.ClientPrint(pPlayer, HUD_PRINTCENTER, "No Creatures to destroy!\n");
            return;
        }

        bool anyDestroyed = false;
        
        // Destroy all Minions from last to first.
        for(int i = MinionCount - 1; i >= 0; i--)
        {
            CBaseEntity@ pExistingMinion = m_hMinions[i].hMinion.GetEntity();
            if(pExistingMinion !is null)
            {
                // Use Killed to destroy active minions naturally.
                pExistingMinion.Killed(pPlayer.pev, GIB_ALWAYS); // Ensure gibbing, incase they are in dying state and revivable.
                anyDestroyed = true;
            }

            // Always remove from array, even if entity pointer is null.
            m_hMinions.removeAt(i);
        }

        // Reset individual reserve pool.
        m_flReservePool = 0.0f;
        
        if(anyDestroyed)
            g_PlayerFuncs.ClientPrint(pPlayer, HUD_PRINTCENTER, "All Creatures killed!\n");
        else
            g_PlayerFuncs.ClientPrint(pPlayer, HUD_PRINTCENTER, "Creatures cleared!\n");
    }
    
    // Reset function to clean up all active minions.
    void Reset()
    {
        // Find the player if possible by iterating through all players.
        CBasePlayer@ pPlayer = null;
        string playerSteamID = "";
        
        if(m_pStats !is null)
        {
            // Loop through all possible player slots.
            for (int i = 1; i <= g_Engine.maxClients; i++)
            {
                CBasePlayer@ tempPlayer = g_PlayerFuncs.FindPlayerByIndex(i);
                if (tempPlayer !is null && tempPlayer.IsConnected())
                {
                    // Get the player's SteamID.
                    string steamID = g_EngineFuncs.GetPlayerAuthId(tempPlayer.edict());
                    
                    // Check if this player has RPG data.
                    if(g_PlayerRPGData.exists(steamID))
                    {
                        PlayerData@ playerData = cast<PlayerData@>(g_PlayerRPGData[steamID]);
                        
                        // Check if this player owns these stats.
                        if(playerData !is null && playerData.GetCurrentClassStats() is m_pStats)
                        {
                            playerSteamID = steamID;
                            @pPlayer = tempPlayer;
                            break;
                        }
                    }
                }
            }
        }
        
        if(pPlayer !is null)
        {
            DestroyAllMinions(pPlayer);
        }
        else
        {   
            // Just in case, try to remove any that might exist
            for(int i = m_hMinions.length() - 1; i >= 0; i--)
            {
                CBaseEntity@ pExistingMinion = m_hMinions[i].hMinion.GetEntity();
                if(pExistingMinion !is null)
                {
                    g_EntityFuncs.Remove(pExistingMinion);
                }
            }
            
            // Clear the array and reset pool
            m_hMinions.resize(0);
            m_flReservePool = 0.0f;
        }
    }

    void MinionRegen()
    {
        // Only process regen if enough time has passed.
        float currentTime = g_Engine.time;
        if(currentTime - m_flLastRegenTime < m_flRegenInterval)
            return;
            
        m_flLastRegenTime = currentTime;

        for(uint i = 0; i < m_hMinions.length(); i++)
        {
            CBaseEntity@ pMinion = m_hMinions[i].hMinion.GetEntity();
            if(pMinion !is null)
            {
                // Cast to CBaseMonster to check monster-specific properties.
                CBaseMonster@ pMonster = cast<CBaseMonster@>(pMinion);
                
                // Only regenerate if the monster is alive (not in a dying state).
                if(pMonster !is null && pMonster.pev.deadflag == DEAD_NO && pMinion.pev.health > 0)
                {
                    // Ensure max_health is properly set.
                    if(pMinion.pev.max_health <= 0) 
                    {
                        // Get the creature type from our stored information.
                        int creatureType = m_hMinions[i].type;
                        
                        // Use our scaled health formula that accounts for player level.
                        pMinion.pev.max_health = GetScaledHealth();
                    }

                    float flHealAmount = pMinion.pev.max_health * m_flHealthRegen; // Calculate amount from max health.

                    if(pMinion.pev.health < pMinion.pev.max_health)
                    {
                        pMinion.pev.health = Math.min(pMinion.pev.health + flHealAmount, pMinion.pev.max_health); // Add health.

                        if(pMinion.pev.health > pMinion.pev.max_health) 
                            pMinion.pev.health = pMinion.pev.max_health; // Clamp to max health.
                    }
                }
            }
        }
    }

    float GetScaledHealth()
    {
        if(m_pStats is null)
            return m_flBaseHealth; // Base health without scaling if no stats.

        float level = m_pStats.GetLevel();
        float flScaledHealth = m_flBaseHealth * (1.0f + (float(level) * m_flHealthScale));
        return flScaledHealth;
    }

    float GetScaledDamage() // Damage scaling works a little differently, through MonsterTakeDamage.
    {
        if(m_pStats is null)
            return 0.0f; // Technically should never be zero, but is always null when we have no minions.

        float level = m_pStats.GetLevel();
        float flScaledDamage = (float(level) * m_flDamageScale); // Essentially just increasing the multiplier per level as there is no base damage.
        return flScaledDamage;
    }
    
    void ApplyMinionGlow(CBaseEntity@ pMinion)
    {
        if(pMinion is null)
            return;
            
        // Apply the glowing effect.
        pMinion.pev.renderfx = kRenderFxGlowShell; // Glow shell.
        pMinion.pev.rendermode = kRenderNormal; // Render mode.
        pMinion.pev.renderamt = 1; // Shell thickness.
        pMinion.pev.rendercolor = Vector(100, 250, 150); // Lime.
    }
    
    void RecalculateReservePool()
    {
        // Recalculate the reserve pool based on current minions.
        float newReservePool = 0.0f;
        
        // Process from last to first to allow safe removal during iteration
        for(int i = int(m_hMinions.length()) - 1; i >= 0; i--)
        {
            // First verify the minion actually exists and is alive
            CBaseEntity@ pMinion = m_hMinions[i].hMinion.GetEntity();
            if(pMinion is null || !pMinion.IsAlive() || pMinion.pev.health <= 0)
            {
                // Invalid or dead minion, remove it from our tracking
                m_hMinions.removeAt(i);
                continue;
            }
            
            // Only count valid, alive minions toward the reserve pool
            int minionType = m_hMinions[i].type;
            if(minionType >= 0 && uint(minionType) < XEN_COSTS.length())
            {
                newReservePool += XEN_COSTS[minionType];
            }
        }
        
        // Update the reserve pool.
        m_flReservePool = newReservePool;
    }

    // Called when a minion deals damage to an enemy.
    void ProcessMinionDamage(CBasePlayer@ pPlayer, float flDamageDealt)
    {
        if(pPlayer is null || !pPlayer.IsConnected() || !pPlayer.IsAlive())
            return;
            
        // Check if the enhancement is unlocked.
        if(m_pStats is null || !m_pStats.HasUnlockedPerk1())
            return;

        // Calculate health to return to player and minion.
        float flHealthToGive = flDamageDealt * m_flLifestealPercent;
        
        // Apply the healing if the player isn't already at max health.
        if(pPlayer.pev.health < pPlayer.pev.max_health)
        {
            pPlayer.pev.health = Math.min(pPlayer.pev.health + flHealthToGive, pPlayer.pev.max_health);
            
            // Visual feedback for the lifesteal effect - Heal sprites - Player.
            Vector pos = pPlayer.pev.origin;
            Vector mins = pos - Vector(16, 16, 0);
            Vector maxs = pos + Vector(16, 16, 64);

            NetworkMessage healeffect(MSG_BROADCAST, NetworkMessages::SVC_TEMPENTITY);
            healeffect.WriteByte(TE_BUBBLES);
            healeffect.WriteCoord(mins.x);
            healeffect.WriteCoord(mins.y);
            healeffect.WriteCoord(mins.z);
            healeffect.WriteCoord(maxs.x);
            healeffect.WriteCoord(maxs.y);
            healeffect.WriteCoord(maxs.z);
            healeffect.WriteCoord(80.0f); // Height of the bubble effect
            healeffect.WriteShort(g_EngineFuncs.ModelIndex(strHealAuraEffectSprite));
            healeffect.WriteByte(18); // Count
            healeffect.WriteCoord(6.0f); // Speed
            healeffect.End();
        }
        
        // Find the active minion that dealt the damage (most likely the last one that dealt damage).
        // Needs better tracking, currently heals all minions.
        for(uint i = 0; i < m_hMinions.length(); i++)
        {
            CBaseEntity@ pMinion = m_hMinions[i].hMinion.GetEntity();
            if(pMinion !is null)
            {
                // Cast to CBaseMonster to check monster-specific properties.
                CBaseMonster@ pMonster = cast<CBaseMonster@>(pMinion);
                
                // Only heal if the monster is alive.
                if(pMonster !is null && pMonster.pev.deadflag == DEAD_NO && pMinion.pev.health > 0)
                {
                    // Apply healing to the minion if it's not at max health.
                    if(pMinion.pev.health < pMinion.pev.max_health)
                    {
                        pMinion.pev.health = Math.min(pMinion.pev.health + flHealthToGive, pMinion.pev.max_health);

                        // Visual feedback for the lifesteal effect - Heal sprites - Minion.
                        Vector pos = pMinion.pev.origin;
                        Vector mins = pos - Vector(16, 16, 0);
                        Vector maxs = pos + Vector(16, 16, 64);

                        NetworkMessage healeffect(MSG_BROADCAST, NetworkMessages::SVC_TEMPENTITY);
                        healeffect.WriteByte(TE_BUBBLES);
                        healeffect.WriteCoord(mins.x);
                        healeffect.WriteCoord(mins.y);
                        healeffect.WriteCoord(mins.z);
                        healeffect.WriteCoord(maxs.x);
                        healeffect.WriteCoord(maxs.y);
                        healeffect.WriteCoord(maxs.z);
                        healeffect.WriteCoord(80.0f); // Height of the bubble effect.
                        healeffect.WriteShort(g_EngineFuncs.ModelIndex(strHealAuraEffectSprite));
                        healeffect.WriteByte(18); // Count.
                        healeffect.WriteCoord(6.0f); // Speed.
                        healeffect.End();
                    }
                }
            }
        }
    }

    void TeleportMinions(CBasePlayer@ pPlayer)
    {
        if(pPlayer is null || !pPlayer.IsConnected() || !pPlayer.IsAlive())
            return;

        if(m_hMinions.length() == 0)
        {
            g_PlayerFuncs.ClientPrint(pPlayer, HUD_PRINTCENTER, "No Creatures to teleport!\n");
            return;
        }

        Vector playerPos = pPlayer.pev.origin;
        Vector spawnForward, spawnRight, spawnUp;
        float radius = 60.0f;
        float angleStep = (180.0f / m_hMinions.length());

        for(uint i = 0; i < m_hMinions.length(); i++)
        {
            CBaseEntity@ pMinion = m_hMinions[i].hMinion.GetEntity();
            if(pMinion !is null)
            {
                float angle = angleStep * i;
                g_EngineFuncs.AngleVectors(Vector(0, angle, 0), spawnForward, spawnRight, spawnUp);
                Vector offset = spawnForward * radius;
                pMinion.pev.origin = playerPos + offset;
                pMinion.pev.angles = pPlayer.pev.angles;
            }
        }

        g_SoundSystem.EmitSound(pPlayer.edict(), CHAN_STATIC, strXenMinionSoundCreate, 1.0f, ATTN_NORM);
        g_PlayerFuncs.ClientPrint(pPlayer, HUD_PRINTCENTER, "Creatures teleported!\n");
    }
}

class XenMinionMenu 
{
    private CTextMenu@ m_pMenu;
    private XenMinionData@ m_pOwner;
    
    XenMinionMenu(XenMinionData@ owner) 
    {
        @m_pOwner = owner;
    }
    
    void ShowXenMinionMenu(CBasePlayer@ pPlayer) 
    {
        if(pPlayer is null) return;
        
        @m_pMenu = CTextMenu(TextMenuPlayerSlotCallback(this.MenuCallback));
        m_pMenu.SetTitle("[Xen Creatures Control Menu]\n");
        
        for(uint i = 0; i < XEN_NAMES.length(); i++) 
        {
            string menuText = "";

            // Check if this minion type is unlocked.
            if(!m_pOwner.IsMinionTypeUnlocked(i))
            {
                menuText += "Summon " + XEN_NAMES[i] + " (Lv. " + XEN_LEVEL_REQUIREMENTS[i] + ")";
            }
            else
            {
                menuText += "Summon " + XEN_NAMES[i] + " (Cost: " + XEN_COSTS[i] + ")";
            }
            
            m_pMenu.AddItem(menuText + "\n", any(i));
        }
        
        if(m_pOwner.GetMinionCount() > 0) 
        {
            m_pMenu.AddItem("Teleport All\n", any(98));
            m_pMenu.AddItem("Kill All\n", any(99));
        }
        
        m_pMenu.Register();
        m_pMenu.Open(0, 0, pPlayer);
    }
    
    private void MenuCallback(CTextMenu@ menu, CBasePlayer@ pPlayer, int page, const CTextMenuItem@ item) 
    {
        if(item !is null && pPlayer !is null) 
        {
            int choice;
            item.m_pUserData.retrieve(choice);
            
            if(choice == 99) 
            {
                // Destroy all minions.
                m_pOwner.DestroyAllMinions(pPlayer);
            }
            else if(choice == 98)
            {
                // Teleport existing minions.
                m_pOwner.TeleportMinions(pPlayer);
            }
            else if(choice >= 0 && uint(choice) < XEN_NAMES.length())
            {
                // Check if this minion type is unlocked.
                if(!m_pOwner.IsMinionTypeUnlocked(choice))
                {
                    g_PlayerFuncs.ClientPrint(pPlayer, HUD_PRINTCENTER, "" + XEN_NAMES[choice] + " requires Lv. " + XEN_LEVEL_REQUIREMENTS[choice] + "!\n");
                    return;
                }
                
                // Spawn new minion.
                m_pOwner.SpawnSpecificMinion(pPlayer, choice);
            }
        }
    }
}

void CheckXenologistMinions()
{   
    // Iterate directly through all player slots instead of using g_PlayerRPGData.getKeys()
    for (int i = 1; i <= g_Engine.maxClients; i++)
    {
        CBasePlayer@ pPlayer = g_PlayerFuncs.FindPlayerByIndex(i);
        if (pPlayer is null || !pPlayer.IsConnected())
            continue;
            
        // Get the player's SteamID
        string steamID = g_EngineFuncs.GetPlayerAuthId(pPlayer.edict());
        
        // Skip if player doesn't have RPG data
        if (!g_PlayerRPGData.exists(steamID))
            continue;
            
        // Initialize MinionData if it doesn't exist.
        if(!g_XenologistMinions.exists(steamID))
        {
            XenMinionData data;
            @g_XenologistMinions[steamID] = data;
        }

        XenMinionData@ xenMinion = cast<XenMinionData@>(g_XenologistMinions[steamID]);
        if(xenMinion !is null)
        {
            // Reset all minions on first check after map load or plugin reload.
            if(!xenMinion.IsActive())
            {
                //g_Game.AlertMessage(at_console, "CARPG: Resetting Xenomancer minions for player " + steamID + " on map load\n");
                xenMinion.Reset();
            }
            
            // Check if player switched class.
            if(g_PlayerRPGData.exists(steamID))
            {
                PlayerData@ data = cast<PlayerData@>(g_PlayerRPGData[steamID]);
                if(data !is null)
                {
                    if(data.GetCurrentClass() != PlayerClass::CLASS_XENOMANCER)
                    {
                        // Player is no longer this class, destroy active minions.
                        if(xenMinion.GetMinionCount() > 0)
                        {
                            xenMinion.DestroyAllMinions(pPlayer);
                            continue;  // Skip rest of updates.
                        }
                    }
                    else if(!xenMinion.HasStats())
                    {
                        // Update stats.
                        xenMinion.Initialize(data.GetCurrentClassStats());
                    }
                }
            }
            
                // Make sure resource limits are enforced.
                if(g_PlayerClassResources.exists(steamID))
                {
                    dictionary@ resources = cast<dictionary@>(g_PlayerClassResources[steamID]);
                    if(resources !is null)
                    {
                        // First recalculate the reserve pool to ensure it's accurate
                        xenMinion.RecalculateReservePool();
                        
                        float maxEnergy = float(resources['max']);
                        if(xenMinion.GetReservePool() > maxEnergy)
                        {
                            // Over the limit, destroy minions until we're within limits.
                            xenMinion.DestroyAllMinions(pPlayer);
                        }
                    }
                }

            xenMinion.MinionRegen(); // Minion Regeneration.

            // Always update scaling values for stats menu.
            xenMinion.GetScaledHealth();
            xenMinion.GetScaledDamage();

            // Always run XenUpdate for proper minion tracking
            xenMinion.XenUpdate(pPlayer);
        }
    }
}